# Optimizer & Hint

MySQL에서는 쿼리를 최적으로 실행하기 위해서 각 테이블의 데이터가 어떤 분포로 저장돼 있는지 통계 정보를 참조하여
쿼리를 수행할 최적의 계획 수립을 한다. 이 작업을 옵티마이저가 이 작업을 한다. 


## 쿼리 실행 절차 
1. 사용자로부터 요청된 쿼리를 쪼개서 서버가 이해할 수 있는 수준으로 분리 한다(Parse Tree)
2. SQL 파싱 정보(Parse Tree)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 사용할지 선택한다.
3. 정해진 순서대로 데이터를 가져온다. 

(1) 단계를 SQL Parsing이라고 하고 SQL Parser라는 모듈로 처리한다. SQL 문법 오류가 이 단계에서 걸러진다.
(2) 단계는 Parse Tree를 참고하며

1. 불필요한 조건 제거 및 복잡한 연산 단순화
2. 여러 테이블 조인이 있을 경우 읽을 테이블 순서 결정
3. 각 테이블에 사용된 조건과 인덱스 통계 정보로 사용할 인덱스 결정
4. 가져온 레코드들을 임시 테이블에 넣고 다시 한 번 가공해야 하는지 결정

특히 이 두 번쨰 단계는 최적화 및 실행 계획 수립 단계다. 옵티마이저에서 처리한다. 이 단계가 완료되면 실행 계획이 만들어진다.
(3) 단계는 수립된 수행 계획으로 실제 읽도록 요청하고 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행한다. 

1,2 는 거의 MySQL엔진, 3번째는 MySQL엔진, Storage 엔진이 동시에 처리한다.


## 옵티마이저의 종류
옵티마이저는 DB의 두뇌와 같은 역할을 한다. 현재 대부분의 DBMS가 채택한 비용 기반 최적화( Cost-based Optimizer, CBO)와 규칙 기반 최적화
(Rule-based Optimizer, RBO)로 나눌 수 있다. 

- 규칙 기반 최적화는 대상 테이블의 레코드 건수, 선택도 등을 고려하지 않고 옵티아미저에 내장된 우선순위에 따라 실행 계획을 수립한다.
이 방식에느 통계 정보(레코드 건수, 컬럼값의 분포도)를 조사하지 않고 실행 계획이 수립되므로 같은 쿼리에 대해서 항상 같은 실행 방법을 
만들어낸다.

- 비용 기반 최적화는 쿼리 처리를 위해서 여러 가지 가능한 방법으로 만들고 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해서
실행 계획별 비용을 산출한다. 이렇게 산출된 비용이 낮은 계획으로 쿼리를 실행한다. 


### 풀 스캔, 풀 인덱스 스캔
풀 스캔, innoDB에서는 하나씩 페이지를 읽는 것이 아니라 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운 쓰레드로 리어 어헤드(Read ahead) 작업을 자동으로 시작한다.
그래서 요청을 예측하여 미리 버퍼 풀에 가져다 둔다. 즉, 풀 테이블 스캔이 실행되면 처음 몇 개는 포그라운드(Foreground)로 읽지만 특정 시점부터는 백그라운드에서 
예측하여 처리하기 시작한다. 백그라운드 쓰레드로 읽기를 넘겨 받으면 한 번에 4 ~ 8개의 페이지를 읽고 계속 그 수를 증가 시킨다. 이 때 한 번에 64개까지 읽어서 
버퍼풀에 저장한다. `innodb_read_ahead_threshold`로 언제 ahead 할지 정할 수 있다. 이는 풀 인덱스 스캔에서도 같다.

### 병렬 처리
8.0부터 병렬 처리가 가능해졌다. `innodb_parallel_read_trheads`라는 시스템 변수로 하나의 쿼리를 몇 개의 쓰레드로 처리할지 정할 수 있다. 아직
쿼리를 여러 개의 쓰레드를 이용해서 병렬로 처리하게 하는 힌트나 옵션은 없다. WHERE 없이 전체 건수를 가져오는 쿼리에서만 병렬로 처리할 수 있다.

### ORDER BY
정렬을 처리하는 방법은 인덱스를 이용하는 방법과 쿼리가 실행될 때 "Filesort"로 별도 처리하는 방법으로 나눌 수 있다.

|    \     |                                         장점                                          | 단점                                                                                                                       |
|:--------:|:-----------------------------------------------------------------------------------:|:-------------------------------------------------------------------------------------------------------------------------|
|   인덱스    |         INSERT, UPDATE, DELETE 쿼리가 실행될 때 인덱스가 정렬돼 있어서 순서대로 읽기만 하면 된다. 빠르다.          | 해당 작업들 진행시 부가적 인덱스 추가/ 삭제 작업이 필요하므로 느리다. <br/>인덱스 떄문에 디스크 공간이 더 많이 필요하다. <br/>인덱스 개수가 늘어날수록 innoDB 버퍼풀을 위한 메모리가 많이 필요하다. |
| Filesort | 인덱스 생성이 없어서 인덱스 이용할 때 단점이 장점으로 바뀐다. <br/>정렬할 레코드가 많이 않으면 메모리에서 Filesort가 진행되므로 빠르다. | 정렬 작업이 쿼리 실행시 처리되므로 레코드 대상 건수가 많이질수록 쿼리 응답 속도가 느리다.                                                                      |

물론 레코드 정렬을 위해서 무조건 Filesort를 이용해야하는 것은 아니다. 하지만 아래와 같은 이유로 모든 정렬을 인덱스를 이용하도록 튜닝하기란 어렵다.

1. 정렬 기준이 너무 많이서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
2. GROUP BY의 결과 또는 DISTINCT 같은 처리를 정렬해야하는 경우
3. UNION같이 임시테이블의 결과를 다시 정렬해야하는 경우
4. 랜덤하게 결과 레코드를 가져와야 하는 경우

MySQL에서 인덱스 이용 없이 별도 정렬처리를 수행했는지는 실행 계획의 Extra 컬럼에 Using Filesort가 있는지로 판단할 수 있다. 

### Sort Buffer
MySQL는 정렬을 위해서 별도 메모리 공간을 할당 받는데 이를 SortBuffer라고 한다. 소트 버퍼는 정령이 필요한 경우에만 할당되며, 버퍼의 크기는 정렬해야 할 레코드의
크기에 따라 가변적으로증가하지만 최대 사용 가능한 소트 버퍼 공간은 `sort_buffer_size`라는 시스템 변수로 설정할 수 있다. 이 공간은 쿼리 실행이 완료되면 시스템으로 즉시
반납된다.

만약 정렬해야할 레코드가 소트 버퍼보다 크면? 이러면 MySQL은 정렬해야할 레코드를 여러 조각으로 나눠서 처리한다. 이 과정에서 임시 저장을 위해서 디스크를 사용한다.
메모리의 소트 버퍼에서 정렬을 수행하고 그 결과를 임시 디스크에 기록한다. 그 다음 레코드를 가져와서 다시 정렬해서 반복적으로 디스크에 임시 저장한다. 이처럼 각 버퍼 크기만큼
정렬된 레코드를 다시 병합하면서 정렬을 수행한다. 이 병렬 작업을 멀티 머지(Multi-merge)라고 한다. 수행된 멀티 머지 횟수는 Sort_merge_passes라는 상태 변수에
누적 집계된다.

이 작업들이 모두 디스크의 쓰기와 읽기를 유발하며, 레코드 건수가 많을수록 이 반복 작업의 횟수가 많아진다. 소트 버퍼를 크게 설정하면 디스크를 사용하지 않아서 
더 빨라질 것으로 보이나, 실제로는 큰 영향이 없다. 오히려 너무 큰 `sort_buffer_size`를 사용하면 큰 메모리 공강 할당 때문에 성능이 떨어질 수 있다.

### 정렬 알고리즘
레코드 정렬 시 레코드 전체를 소트 버퍼에 담을지, 정렬 기준만 담을지는 싱글 패스, 투 패스 2가지 정렬 모드로 나눌 수 있다.

```mysql
SET OPTIMIZER_TRACE = "enabled=on", END_MARKERS_IN_JSON = on;
SET OPTIMIZER_TRACE_MAX_MEM_SIZE = 1000000;

SELECT * FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;
```

싱글 패스는 SELECT 대상이 되는 컬럼을 전부 담아서 정렬을 수행하는 방식, 투 패스는 정렬 대상과 컬럼 PK만 소트 버퍼에 담아서 정렬을 수행하고 
정렬 순서대로 다시 PK로 테이블을 읽어서 SELECT할 컬럼을 가져오는 방식이다. 대부분 싱글 패스를 사용하지만 아래의 경우, 투 패스를 사용하기도 한다.
- 레코드의 크기가 `max_length_for_sort_data`보다 큰 경우
- BLOB, TEXT 타입이 SELECT 대상에 있을 경우

> `SELECT * FROM`이 되면 문제가 생기는 경우가 이 부분이다.

### 정렬 처리 방법

|          정렬 처리 방법           |       실행 계획의 Extra 컬럼 내용        |
|:---------------------------:|:-------------------------------:|
|           인덱스 정렬            |              표기 X               |
|      조인에서 드라이빙 테이블만 정렬      |         Using filesort          |
| 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 | Using temporary; Using filesort |


먼저 옵티마이저는 정렬 처리를 위해서 인덱스 이용이 가능한지 검토한다. 인덱스를 이용할 수 있다면 filesort 없이 인덱스를 순서대로 읽어서 결과를 반환한다.
하지만 인덱스를 사용할 수 없다면 WHERE에 일치하는 레코드를 검색해서 정렬 버퍼에 저장하면서 정렬을 처리한다. 이때 MySQL 옵티마이저는 정렬 대상 레코드를
최소화하기 위해서 아래 2가지 방법 중 하나를 선택한다.

- 조인의 드라이빙 테이블만 정렬한 다음 조인을 수행
- 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행


### 인덱스를 이용한 정렬
ORDER BY에 명시된 컬럼이 제일 먼저 읽는 테이블에 속하고, ORDER BY 순서대로 생성된 인덱스가 있어야 한다. 또한 WHERE 절 첫 번째로 읽는 테이블의 컬럼에
대한 조건이 있다면 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다. B-TREE가 아닌 Hash,  전문 검색 인덱스 등에서는 인덱스를 이용한 정렬을 사용할 수 없다.
R-TREE 역시 사용할 수 없다. 여러 테이블이 조인되는 경우 Nested-Loop 방식의 조인에서만 이 방식을 사용할 수 있다. 

### 조인의 드라이빙 테이블만 정렬
조인이 실행되면 결과 레코드의 건수가 몇 배로 불어나고, 레코드 하나하나의 크기도 늘어난다. 그래서 조인을 실행하기 전에 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것이
차선책이 된다. 이 방법으로 정려리 처리되려면 조인에서 첫 번쨰로 읽는 테이블의 컬럼만으로 ORDER BY를 작성해야 한다.

### 임시테이블을 사용한 정렬
쿼리가 여러 테이블을 조인하지 않고 하나의 테이블로부터 SELECT 해서 정렬하는 경우라면 임시 테이블이 필요하지 않다. 하지만 2개 이상의 테이블을 조인해서 그 결과를
정렬해야 한다면 임시테이블이 필요할 수도 있다. 앞서 살펴본 조인의 드라이빙 테이블만 정렬은 2개 이상 테이블이 조인되면서 정렬되지만 임시 테이블을 사용하지 않는다.
하지만 그 외 패턴의 쿼리에서는 항상 조인의 결과를 임시 테이블에 저장하고 그 결과를 다시 정렬하는 과정을 거친다.

### 정렬 처리 방법의 성능 비교
ORDER BY와 LIMIT을 같이 사용하기에 작업량이 적은편이다. 그러나 ORDER BY나 GROUP BY와 같은 작업은 WHERE을 만족하는 레코드를 LIMIT로 가져오서 처리할 수는 없다.
우선 조건을 만족하는 모든 레코드를 가져와서 정렬하거나 그루핑을 해야만 LIMIT 할 수 있다. WHERE 조건이 아무리 인덱스를 잘 활용해도 ORDER BY, GROUP BY를 사용하면
쿼리가 느려질 수밖에 없는 이유가 여기에 있다.

쿼리에서 인덱스를 사용하지 못하는 정렬이나 그루핑이 왜 느리게 작동하는지 알아보자. 이를 위해서 쿼리가 처리하는 방법을 '스트리밍 처리', '버퍼링 처리' 2가지 방식으로
구분해보자.

#### 스트리밍
조건에 일치하는 레코드가 검색할 때마다 바로바로 클라이언트에 전송한다. 이 방식으로 쿼리를 처리하면 클라이언트는 쿼리를 요청하고 곧바로 원했던 첫 번째 레코드를 받는다.
마지막 레코드는 언제 받을지 알 수 없다.

이렇게 진행되면 레코드를 찾는 즉시 전달하기에 동시에 데이터 가공 작업을 할 수 있다. 또한, 스트리밍으로 처리하면 처리되는 쿼리가 얼마나 많은 레코드를 조회하느냐에
상관없이 빠른 응답 시간을 보장한다.

또한 스트리밍으로 처리되는 쿼리에서 LIMIT과 같이 건수를 제한하는 쿼리는 전체 실행 시간을 상당히 줄여준다. 

#### 버퍼링
ORDER BY, GROUP BY는 스트리밍을 할 수 없게 한다. 우선 WHERE로 일치하는 레코드를 모두 가져오고 정렬하거나 그루핑해서 차례대로 보내야 한다. 서버에서 
모든 레코드를 검색하고 정렬하는 동안 클라이언트는 기다려야 한다. 그래서 응답 속도가 느려진다.

#### 정렬 관련 상태 변수
MySQL은 주요 작업에 대해서 해당 작업의 실행 횟수를 상태 변수로 저장한다. 정렬과 관련해서도 몇 건의 레코드나 정렬을 했는지, 소트 버퍼 간의 병합 작업은 몇 
번이나 했느지 확인할 수 있다.
```mysql
FLUSH STATUS;
SHOW STATUS LIKE 'Sort%';


+-------------------+-------+
| Variable_name     | Value |
+-------------------+-------+
| Sort_merge_passes | 0     |
| Sort_range        | 0     |
| Sort_rows         | 0     |
| Sort_scan         | 0     |
+-------------------+-------+
4 rows in set (0.02 sec)
```

- Sort_merge_passes: 멀티 머지 처리 횟수 
- Sort_range : 인덱스 레인지 스캔을 통해 검색된 결과에 대한 정렬 작업 횟수
- Sort_scan : 풀 테이블 스캔을 통해서 검색된 결과에 대한 정렬 작업 횟수다. 'Sort_scan'과 'Sort_range'는 둘 다 정렬 작업 횟수를 누적하고 있는 상태 값이다.
- Sort_rows : 지금까지 정렬한 전체 레코드 건수


#### GROUP BY 처리
GROUP BY도 스트리밍을 할 수 없게 한다. GROUP BY에 있는 쿼리는 HAVING을 사용할 수 있는데, HAVING은 GROUP BY의 필터링 역할을 한다. GROUP BY에 
사용된 조건은 인덱스로 처리할 수 없으므로 HAVING에서 튜닝하려고 인덱스를 생성하거나 할 필요가 없다. 

GROUP BY도 인덱스를 사용한 것과 아닌 것으로 나눌 수 있다. 인덱스를 사용하면 인덱스를 차례대로 읽는 인덱스 스캔과 인덱스를 건너뛰면서 읽는 루스 인덱스 스캔으로 나뉜다.
그리고 인덱스를 사용하지 못하는 쿼리에서  GROUP BY는 임시 테이블을 사용한다.

##### 인덱스 스캔을 이용하는 GROUP BY (타이트 인덱스 스캔)
ORDER BY의 경우 조인 드라이빙 테이블에 속한 컬럼만을 이용해서 그루핑 할 떄 GROUP BY 컬럼으로 이미 인덱스가 있으면 그 인덱스를 차례대로 읽으며 그루핑을 수행하고
그 결과로 조인을 처리한다. GROUP BY가 인덱스를 사용해서 처리한다고 해도 `Aggregation function` 등 그룹값을 처리해야 해서 임시 테이블이 필요할 때도 있다.
GROUP BY 가 인덱스를 통해 처리되는 쿼리는 이미 정렬된 인덱스를 읽는 것이므로 쿼리 실행 시점에 추가적인 정렬이나 내부 임시테이블은 필요치 않다. 
이러한 그루핑 방식을 사용하면 쿼리 실행 계획의 Extra에 `Using index for group-by`, `Using temporary, Using filesort`가 표시되지 않는다.


##### 루스 인덱스 스캔을 이용하는 GROUP BY
루스 인덱스 스캔은 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 것을 의미한다. 옵티마이저가 루스 인덱스 스캔을 하면 Extra 컬럼에 `Using index for group-by` 
코멘트가 표시된다. 루스 인덱스 스캔 방식은 단일 테이블에 대해서 수행되는 GROUP BY 처리에만 사용할 수 있다. 또한 `Prefix index`(컬럼 값의 앞쪽 일부만으로 생성된 인덱스)
는 루스 인덱스 스캔을 사용할 수 없다. 인덱스 레인지 스캔에서는 유니크한 값의 수가 많을수록 성능이 향상되는 반면 루스 인덱스 스캔에서는 인덱스의 유니크한 값의 수가 적을수록
성능이 향상된다. 즉, 루스 인덱스 스캔은 분포도가 좋지 않을수록 빠른 결과를 만들어낸다. 또한, 루스 인덱스 스캔으로 처리되는 쿼리에서는 별도 임시 테이블이 필요하지 않다.

##### 임시 테이블을 사용하는 GROUP BY
GROUP BY의 기준 컬럼이 드라이빙 테이블에 있든 드리븐 테이블에 있든 관계 없이 인덱스를 전혀 사용하지 못할 떄는 이 방식으로 처리된다. 
```mysql
EXPLAIN 
    SELECT e.last_name, AVG(s.salary)
    FROM employees e, salaries s
    WHERE s.emp_no = e.emp_no
    GROUP BY e.last_name;
```
이 실행 계획에서는 Extra에 `Using temporary`가 표시된다. FullScan 떄문이 아니라 인덱스를 전혀 사용할 수 없는 GROUP BY 때문이다.
MySQL 8.0전까지는 GRUOP BY가 사용되니 쿼리는 그루핑되는 컬럼을 기준으로 묵시적 정렬까지 함께 수행했다. 8.0에서는 필요한 경우 내부적으로 GROUP BY 절의 
컬럼들로 구성된 유니크 인덱스를 가진 임시 테이블을 만들어서 중복 제거와 집합 함수 연산을 수행한다. 그리고 조인의 결과를 한 건씩 가져와 임시 테이블에서 중복 체크를 하면서
INSERT, UPDATE를 실행한다. 8.0에서도 ORDER BY를 쓰면 Extra에 `Using temporary, Using filesort`가 표시되면서 정렬을 명시적으로 수행한다.


#### DISTINCT
특정 컬럼의 유니크한 값만 조회하려면 DISTINCT를 사용한다. DISTINCT는 MIN(), MAX() 또는 COUNT() 같은 집합 함수와 함께 사용되는 경우와 집합 함수가
없는 경우 2가지로 구분할 수 있다. 이렇게 구분한 이유는 DISTINCT가 각 경우에 따라 미치는 범위가 달라지기 때문이다. 그리고 집합 함수와 같이 DISTICT가 사용되는
쿼리의 실행 계획에서 DISTINCT가 인덱스를 사용하지 못 할 때는 항상 임시 테이블이 필요하다. 

##### SELECT DISTINCT
이 경우는 GROUP BY와 동일한 방식으로 처리된다. (8.0 부터는 order by가 없으면 정렬도 안해서 내부적으로 같은 작업을 한다.)

##### 집합 함수와 함께 사용된 DISTINCT
COUNT() 또는 MIN(), MAX() 같은 집합 함수 내에서 DISTINCT를 사용할 수 있는데, 이러면 SELECT DISTINCT와는 다르게 해석된다. 집합 함수 없는 SELECT
쿼리에서 DISTINCT는 조회하는 모든 컬럼의 조합이 유니크한 것들만 가져온다. 하지만 집합 함수 내에서 사용된 DISTINCT는 그 집합 함수의 인자로 전달된
컬럼 값이 유니크한 것들을 가져온다. 

#### 내부 임시 테이블 사용
MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그루핑할 때는 내부적인 임시 테이블(Internal temporary table)을 사용한다. "내부적(Internal)"
이라는 단어가 포함된 이유는 여기서 얘기하는 임시 테이블은 `CREATE TEMPORARY TABLE`로 만든 것과는 다르기 때문이다. 일반적으로 사용하는 임시테이블은
처음에 메모리에 생성됐다 테이블 크기가 커지면 디스크로 옮겨진다. 특정 예외 케이스에는 메모리를 거치지 않고 바로 디스크에 임시 테이블이 만들어지기도 한다. 
이렇게 사용자가 생성한 임시테이블과는 달리 내부적 임시테이블은 쿼리 처리가 삭제되면 삭제된다. 또한 다른 세션이나 다른 쿼리에서느 볼 수 없으며, 사용하는 것도 불가능하다.

#### 메모리 임시 테이블과 디스크 임시 테이블 
8.0 전까지는 원본 테이블의 스토리지 엔진과 관계없이 임시 테이블이 메모리를 사용할 때는 MEMORY 스토리지 엔진을 사용하며, 디스크에 저장될 때는 MyISAM을 이용한다.
8.0부터는 TempTable이라는 스토리지 엔진을 사용하고 디스크에 저장되는 임시 테이블은 innoDB 스토리지 엔진을 사용하도록 했다.

기존 MEMORY 엔진은 VARBINARY, VARCHAR 같은 가변 길이 타입을 지원하지 못해서 메모리가 낭비됐고, MyISAM은 트랜잭션 지원을 못했다. 그래서 8.0부터
TempTable 엔진이 도입됐다. `internal_tmp_mem_storage_engine` 시스템 변수로 메모리용 임시 테이블을 MEMORY와 TempTable 중 선택할 수 있다. 기본 값은
TempTable이다. `temptable_max_ram`으로 최대 사용 크기를 지정할 수 있다.

지정된 값보다 커지면 메모리의 임시 테이블을 디스크로 기록하는데

1. MMAP 파일로 저장
2. innoDB 테이블로 기록

#### 임시 테이블이 필요한 쿼리
아래의 패턴과 같은 쿼리는 별도 데이터 가공이 필요하므로 임시테이블을 생성한다.

- ORDER BY와 GROUP BY가 명시된 컬럼이 다른 쿼리
- ORDER BY나 GROUP BY가 명시된 컬럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
- DISTINCT, ORDER BY가 동시에 존재하는 경우 DISTINCT가 인덱스로 처리되지 못하는 쿼리 
- UNION, UNION DISTINCT가 사용된 쿼리
- 쿼리 실행 계획에서 select_type이 DERIVED인 쿼리

#### 임시 테이블이 디스크에 생성되는 쿼리

- UNION이나 UNION ALL에서 SELECT 되는 컬럼 중에서 길이가 512 바이트 이상인 크기의 컬럼이 있는 경우
- GROUP BY, DISTINCT 컬럼에서 512 바이트 이상인 크기의 컬럼이 있는 경우
- 메모리 임시 테이블의 크기가 `tmp_table_size` 또는 `max_heap_table_size`보다 크거나 `temptable_max_ram`보다 큰 경우

