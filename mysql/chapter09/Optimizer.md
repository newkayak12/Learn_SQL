# Optimizer & Hint

MySQL에서는 쿼리를 최적으로 실행하기 위해서 각 테이블의 데이터가 어떤 분포로 저장돼 있는지 통계 정보를 참조하여
쿼리를 수행할 최적의 계획 수립을 한다. 이 작업을 옵티마이저가 이 작업을 한다. 


## 쿼리 실행 절차 
1. 사용자로부터 요청된 쿼리를 쪼개서 서버가 이해할 수 있는 수준으로 분리 한다(Parse Tree)
2. SQL 파싱 정보(Parse Tree)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 사용할지 선택한다.
3. 정해진 순서대로 데이터를 가져온다. 

(1) 단계를 SQL Parsing이라고 하고 SQL Parser라는 모듈로 처리한다. SQL 문법 오류가 이 단계에서 걸러진다.
(2) 단계는 Parse Tree를 참고하며

1. 불필요한 조건 제거 및 복잡한 연산 단순화
2. 여러 테이블 조인이 있을 경우 읽을 테이블 순서 결정
3. 각 테이블에 사용된 조건과 인덱스 통계 정보로 사용할 인덱스 결정
4. 가져온 레코드들을 임시 테이블에 넣고 다시 한 번 가공해야 하는지 결정

특히 이 두 번쨰 단계는 최적화 및 실행 계획 수립 단계다. 옵티마이저에서 처리한다. 이 단계가 완료되면 실행 계획이 만들어진다.
(3) 단계는 수립된 수행 계획으로 실제 읽도록 요청하고 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행한다. 

1,2 는 거의 MySQL엔진, 3번째는 MySQL엔진, Storage 엔진이 동시에 처리한다.


## 옵티마이저의 종류
옵티마이저는 DB의 두뇌와 같은 역할을 한다. 현재 대부분의 DBMS가 채택한 비용 기반 최적화( Cost-based Optimizer, CBO)와 규칙 기반 최적화
(Rule-based Optimizer, RBO)로 나눌 수 있다. 

- 규칙 기반 최적화는 대상 테이블의 레코드 건수, 선택도 등을 고려하지 않고 옵티아미저에 내장된 우선순위에 따라 실행 계획을 수립한다.
이 방식에느 통계 정보(레코드 건수, 컬럼값의 분포도)를 조사하지 않고 실행 계획이 수립되므로 같은 쿼리에 대해서 항상 같은 실행 방법을 
만들어낸다.

- 비용 기반 최적화는 쿼리 처리를 위해서 여러 가지 가능한 방법으로 만들고 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해서
실행 계획별 비용을 산출한다. 이렇게 산출된 비용이 낮은 계획으로 쿼리를 실행한다. 


### 풀 스캔, 풀 인덱스 스캔
풀 스캔, innoDB에서는 하나씩 페이지를 읽는 것이 아니라 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운 쓰레드로 리어 어헤드(Read ahead) 작업을 자동으로 시작한다.
그래서 요청을 예측하여 미리 버퍼 풀에 가져다 둔다. 즉, 풀 테이블 스캔이 실행되면 처음 몇 개는 포그라운드(Foreground)로 읽지만 특정 시점부터는 백그라운드에서 
예측하여 처리하기 시작한다. 백그라운드 쓰레드로 읽기를 넘겨 받으면 한 번에 4 ~ 8개의 페이지를 읽고 계속 그 수를 증가 시킨다. 이 때 한 번에 64개까지 읽어서 
버퍼풀에 저장한다. `innodb_read_ahead_threshold`로 언제 ahead 할지 정할 수 있다. 이는 풀 인덱스 스캔에서도 같다.

### 병렬 처리
8.0부터 병렬 처리가 가능해졌다. `innodb_parallel_read_trheads`라는 시스템 변수로 하나의 쿼리를 몇 개의 쓰레드로 처리할지 정할 수 있다. 아직
쿼리를 여러 개의 쓰레드를 이용해서 병렬로 처리하게 하는 힌트나 옵션은 없다. WHERE 없이 전체 건수를 가져오는 쿼리에서만 병렬로 처리할 수 있다.

### ORDER BY
정렬을 처리하는 방법은 인덱스를 이용하는 방법과 쿼리가 실행될 때 "Filesort"로 별도 처리하는 방법으로 나눌 수 있다.

|    \     |                                         장점                                          | 단점                                                                                                                       |
|:--------:|:-----------------------------------------------------------------------------------:|:-------------------------------------------------------------------------------------------------------------------------|
|   인덱스    |         INSERT, UPDATE, DELETE 쿼리가 실행될 때 인덱스가 정렬돼 있어서 순서대로 읽기만 하면 된다. 빠르다.          | 해당 작업들 진행시 부가적 인덱스 추가/ 삭제 작업이 필요하므로 느리다. <br/>인덱스 떄문에 디스크 공간이 더 많이 필요하다. <br/>인덱스 개수가 늘어날수록 innoDB 버퍼풀을 위한 메모리가 많이 필요하다. |
| Filesort | 인덱스 생성이 없어서 인덱스 이용할 때 단점이 장점으로 바뀐다. <br/>정렬할 레코드가 많이 않으면 메모리에서 Filesort가 진행되므로 빠르다. | 정렬 작업이 쿼리 실행시 처리되므로 레코드 대상 건수가 많이질수록 쿼리 응답 속도가 느리다.                                                                      |

물론 레코드 정렬을 위해서 무조건 Filesort를 이용해야하는 것은 아니다. 하지만 아래와 같은 이유로 모든 정렬을 인덱스를 이용하도록 튜닝하기란 어렵다.

1. 정렬 기준이 너무 많이서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
2. GROUP BY의 결과 또는 DISTINCT 같은 처리를 정렬해야하는 경우
3. UNION같이 임시테이블의 결과를 다시 정렬해야하는 경우
4. 랜덤하게 결과 레코드를 가져와야 하는 경우

MySQL에서 인덱스 이용 없이 별도 정렬처리를 수행했는지는 실행 계획의 Extra 컬럼에 Using Filesort가 있는지로 판단할 수 있다. 

### Sort Buffer
MySQL는 정렬을 위해서 별도 메모리 공간을 할당 받는데 이를 SortBuffer라고 한다. 소트 버퍼는 정령이 필요한 경우에만 할당되며, 버퍼의 크기는 정렬해야 할 레코드의
크기에 따라 가변적으로증가하지만 최대 사용 가능한 소트 버퍼 공간은 `sort_buffer_size`라는 시스템 변수로 설정할 수 있다. 이 공간은 쿼리 실행이 완료되면 시스템으로 즉시
반납된다.

만약 정렬해야할 레코드가 소트 버퍼보다 크면? 이러면 MySQL은 정렬해야할 레코드를 여러 조각으로 나눠서 처리한다. 이 과정에서 임시 저장을 위해서 디스크를 사용한다.
메모리의 소트 버퍼에서 정렬을 수행하고 그 결과를 임시 디스크에 기록한다. 그 다음 레코드를 가져와서 다시 정렬해서 반복적으로 디스크에 임시 저장한다. 이처럼 각 버퍼 크기만큼
정렬된 레코드를 다시 병합하면서 정렬을 수행한다. 이 병렬 작업을 멀티 머지(Multi-merge)라고 한다. 수행된 멀티 머지 횟수는 Sort_merge_passes라는 상태 변수에
누적 집계된다.

이 작업들이 모두 디스크의 쓰기와 읽기를 유발하며, 레코드 건수가 많을수록 이 반복 작업의 횟수가 많아진다. 소트 버퍼를 크게 설정하면 디스크를 사용하지 않아서 
더 빨라질 것으로 보이나, 실제로는 큰 영향이 없다. 오히려 너무 큰 `sort_buffer_size`를 사용하면 큰 메모리 공강 할당 때문에 성능이 떨어질 수 있다.

### 정렬 알고리즘
레코드 정렬 시 레코드 전체를 소트 버퍼에 담을지, 정렬 기준만 담을지는 싱글 패스, 투 패스 2가지 정렬 모드로 나눌 수 있다.

```mysql
SET OPTIMIZER_TRACE = "enabled=on", END_MARKERS_IN_JSON = on;
SET OPTIMIZER_TRACE_MAX_MEM_SIZE = 1000000;

SELECT * FROM INFORMATION_SCHEMA.OPTIMIZER_TRACE;
```

싱글 패스는 SELECT 대상이 되는 컬럼을 전부 담아서 정렬을 수행하는 방식, 투 패스는 정렬 대상과 컬럼 PK만 소트 버퍼에 담아서 정렬을 수행하고 
정렬 순서대로 다시 PK로 테이블을 읽어서 SELECT할 컬럼을 가져오는 방식이다. 대부분 싱글 패스를 사용하지만 아래의 경우, 투 패스를 사용하기도 한다.
- 레코드의 크기가 `max_length_for_sort_data`보다 큰 경우
- BLOB, TEXT 타입이 SELECT 대상에 있을 경우

> `SELECT * FROM`이 되면 문제가 생기는 경우가 이 부분이다.

### 정렬 처리 방법

|          정렬 처리 방법           |       실행 계획의 Extra 컬럼 내용        |
|:---------------------------:|:-------------------------------:|
|           인덱스 정렬            |              표기 X               |
|      조인에서 드라이빙 테이블만 정렬      |         Using filesort          |
| 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 | Using temporary; Using filesort |


