# 인덱스
## 인덱스란?
DBMS도 DB 테이블 모든 데이터를 검색해서 원하는 겨로가를 가져오려면 시간이 오래 걸린다. 그래서 컬럼(또는 ~들)의 값과 해당 레코드가 저장된
주소를 키-값으로 삼아 인덱스를 만들어 두는 것이다. 

인덱스는 데이터를 관리하는 방식(알고리즘)과 중복 값 허용 여부 등에 따라 여러 가지로 나눌 수 있다. 
- PK는 해당 레코드를 대표하는 컬럼으로 만들어진 인덱스를 의미한다. 이 컬럼은 테이블에서 해당 레코드를 식별할 수 있는 기준 값이 되므로 식별자라고도 부른다.
NOT NULL, UNIQUE가 특징이다.
- PK를 제외하면 SecondaryIndex이다. 대체 키라고도 부를 수 있다. 

데이터 저장 방식(알고리즘)으로 구분하면 대표적으로 B-Tree, Hash 인덱스로 구분할 수 있다. 

- B-TREE : 컬럼의 값을 변형하지 않고 원래 값을 사용해서 인덱싱하는 알고리즘이다. 위치기반 검색을 지원하기 위해서 B-TREE를 응용한 R-TREE 알고리즘도 있다.
- Hash : 컬럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘이다. 매우 빠르다. 값을 변형하므로 전방일치와 같이 값의 일부만 검색하거나 범위 검색을 할 때는 
해시 인덱스를 사용할 수 없다. 주로 메모리 기반 DB에서 사용한다. 

## B-TREE
B-TREE의 B는 Balanced를 의미한다. 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다. 

### 구조 및 특성
B-TREE는 하나의 루트 노드가 존재하고 하위에 자식 노드가 붙어있는 형태다. 가장 하위는 리프 노드다. 루트도 아니고 리프도 아닌 중간 노드를 브랜치 노드라고 한다. 


## B-TREE 인덱스 키 추가/ 삭제

### 추가
B-TREE에 저장될 때는 적절한 위치를 검색해야 한다. 저장될 위치가 결정되면 레코드의 키 값과 대상 레코드의 주소 정보를 B-TREE의 리프 노드에 저장한다. 리프 노드가
꽉 차서 더 저장이 불가하면 리프 노드가 분리된다. 이는 상위 브랜치 노드까지 처리의 범위가 넓어진다. 이런 이유로 B-TREE는 상대적으로 쓰기 작업에 비용이 많이든다.

### 삭제
B-TREE의 리프 노드를 찾아서 삭제 마크만 하면 작업이 완료된다. 삭제 마킹된 키 공간은 그대로 방치하거나 재활용할 수 있다. 

### 키 변경
인덱스의 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 B-TREE 키 값이 변경되면 단순히 인덱스상의 키 값만 변경하는 것이 아니라 먼저 키를 삭제하고 
다시 새로운 키를 추가하는 방식으로 처리된다. 

### 검색
INSERT, UPDATE, DELETE에 많은 비용을 쏟는 이유는 검색에서 이점을 가져가기 위해서이다. B-TREE는 루트 노드부터 시작해서 브랜치를 거쳐 최종 리프 노드까지
이동하면서 비교 작업을 진행하는데, 이를 트리 검색이라고 한다. B-TREE 인덱스를 이용한 검색은 완전 일치 혹은 값의 앞 부분만 일치하는 경우 사용할 수 있다. 

innoDB의 인덱스는 더 특별한 의미가 있다. innoDB 테이블에서 지원하는 레코드 잠금이나 넥스트 키락(갭락)이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를
잠그는 식으로 되어 있다. 따라서 UPDATE, DELETE가 실행될 때 적절히 사용할 인덱스가 없으면 불필요하게 많은 레코드를 잠근다. 

## B-TREE 사용에 영향을 미치는 요소
B-TREE 인덱스는 인덱스를 구성하는 컬럼의 크기와 레코드의 건수, 유니크한 인덱스 키 값 개수 등에 의해서 겁색이나 변경 작업의 성능이 영향을 받는다. 

### 인덱스 키 값의 크기
innoDB의 저장 기본 단위는 페이지 혹은 블록이며, 디스크 읽기 쓰기의 최소 단위가 된다. 또한 버퍼 풀 버퍼링의 기본 단위다. 결국 인덱스도 페이지 단위로 관리 된다.
일반적 DBMS의 B-TREE는 자식 노드의 개수가 가변적 구조다. 자식 노드를 가지는 개수는 인덱스의 페이지 크기와 키 값의 크기에 따라 결정된다.

### B-TREE의 깊이
B-TREE 인덱스의 깊이는 중요하지만 제어할 수는 없다. B-TREE 깊이는 MySQL에서 검색할 때 몇 번이나 랜덤하게 디스크를 읽어야 하는지와 직결되는 문제다.
결론적으로 인덱스 키 값 크기가 커지면 커질 수록 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지고 그 때문에 같은 레코드 건수라고 해도
B-TREE Depth가 깊어져서 디스크 읽기가 더 많이 필요하게 된다. 

### 선택도(기수성)
인덱스에서 Selectivity, Cardinality는 거의 같은 의미로 사용되며, 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다. 유니크한 값이 10개면 기수성은 10 개이다.
중복이 많이질수록 기수성은 낮아지고 선택도 또한 떨어진다. 선택도가 높을수록 빠르게 선택된다.

### 읽어야 하는 레코드 건수
인덱스로 레코드를 읽는 것이 그냥 레코드를 읽는 것이 더 큰 비용이 든다. 인덱스로 읽어내는 것이 더 저렴할지 전체 읽고 필요한 부위만 덜어낼지 판단해야 한다. 
전체 테이블의 20 ~ 25%가 필요한 거라면 전체를 읽고 필터링하는게 나을 수도 있다. 


## B-TREE 인덱스를 통한 읽기
### 인덱스 레인지 스캔
인덱스를 통해 한 건만 읽는 경우와 한 건 이상을 읽는 경우를 레인지 스캔이라고 한다. 시작 위치를 스캔하고 종료 지점까지의 스캔으로 진행된다. 인덱스는 정순 또는 역순으로
정렬된 상태로 레코드를 가져온다. 인덱스 자체 정렬 때문에 벌어지는 일이다.

추가적으로 데이터 파일에러 레코드를 읽어오는 과정이 수반된다. 이 때 레코드 한 건 한 건 단위로 랜덤 I/O가 벌어진다. 

1. 인덱스 조건을 만족하는 값이 저장된 위치를 찾는다.(인덱스 탐색)
2. 탐색된 위치부터 필요한 만큼 인덱스를 읽는다. (인덱스 스캔)
3. 키-레코드 주소로 레코드가 저장된 페이지를 가져오고 최종 레코드를 읽어온다. 

### 인덱스 풀 스캔
인덱스 래인지와 마찬가지로 인덱스를 사용하지만 인덱스를 처음부터 끝까지 읽는 방식을 풀 스캔이라고 한다. 대표적으로 인덱스로 지정된 (A,B,C) 컬럼 중 후 순위(B, C)로
검색하는 경우 풀 스캔이 발생한다.
일반적으로 인덱스가 테이블 크기보다 작으므로 처음부터 끝까지 테이블 풀 스캔보다는 인덱스가 더 저렴하다. 

### 루스 인덱스 스캔
일전의 인덱스 스캔과는 상반된 듬성듬성 인덱스를 읽는 것을 의미한다. 인덱스 레인지 스캔과 비슷하지만 중간에 필요치 않은 인덱스 키 값은 무시하고 넘어간다. 
```mysql
SELECT dept_no, MIN(emp_no)
FROM dept_emp
WHERE dept_no BETWEEN 'd002' AND 'd004'
GROUP BY dept_no;

-- 두 개의 컬럼 밖에 없는 테이블, 인덱스가 dept_no, emp_no로 걸려 있다. 
-- 그러면 dept_no의 첫 번째 레코드만 읽어도 된다. 
```


### B-TREE 인덱스 정렬 및 스캔 방향
인덱스를 생성할 때 설정한 규칙에 따라서 인덱스의 키 값은 항상 오름차순이거나 내림차순으로 정렬된다. 정렬 순서랑 상관 없이 앞에서 뒤로 뒤에서 앞으로도 읽을 수 있다.
인덱스 방향은 옵티마이저가 결정한다.


### B-TREE 인덱스의 가용성과 효율성
WHERE, GROUP BY, ORDER BY가 어떤 경우 인덱스를 사용할 수 있고 어떤 방식으로 사용할 수 있는지 알아야 한다. 그래야만 쿼리 조건을 최적화하거나,
역으로 쿼리에 맞게 인덱스를 최적으로 생성할 수 있다. 

## R-TREE 인덱스
공간 인덱스(Spatial Index)는 R-TREE 알고리즘을 이용해서 2차원의 데이터를 인덱싱하고 검색하는 목적의 인덱스다. 기본적인 내부 메커니즘은 B-TREE와 흡사하다.
B-TREE 인덱스를 구성하는 컬럼의 값이 1차원의 스칼라 값인 반면, R-TREE 인덱스는 2차원 공간 개념 값이라는 것이다. 

위치 기반의 서비스를 구현하는 방법은 여러 가지가 있겠지만 MySQL의 공간 확장(Spatial Extension)을 사용하면 간단히 구현할 수 있다.

- 공간 데이터를 저장할 수 있는 데이터 타입
- 공간 데이터의 검색을 위한 공간 인덱스 (R-TREE 알고리즘)
- 공간 데이터의 연산 함수(거리 또는 포함 관계의 처리)

### 구조 및 특성

`Point > Line > Polygon > Geometry`

와 같이 구성어 있으며 Geometry는 나머지 둘의 Super 타입이다. R-TREE 알고리즘을 이해하려면 MBR(Minimum Bounding Rectangle)을 알아야 한다.
해당 도형을 감싸는 최소 크기 사각형으로 이 사각형들의 포함 관계를 B-TREE 형태로 구현한 인덱스가 R-TREE 인덱스다.

## 클러스터링 인덱스
MySQL에서 클러스터링은 테이블의 레코드를 비슷한 것(PK 기준)으로 묶어서 저장하는 형태로 구현되는데, 주로 비슷한 값을 동시에 조회하는 점에서 착안한 것이다.
여기서 중요한 것은 PK의 키 값에 의해서 레코드의 저장 위치가 결정된다는 것이다. 또한 PK 키 값이 변경되면 레코드의 물리적 위치가 바뀌어야 한다는 것을 의미하기도 
한다. 따라서 PK 지정에 신중해야 한다. PK에 의해 저장 위치가 결정되므로 사실 인덱스 알고리즘이 아닌 레코드 저장 방식이라고도 볼 수 있다. 

만약 PK가 없는 테이블은 어떻게 클러스터링 테이블로 구성될까?
1. PK가 있으면 PK로 클러스터링
2. NOT NULL 옵션의 유니크 인덱스(UNIQUE INDEX) 중에서 첫 번째를 클러스터링 키로 선택
3. 자동으로 UNIQUE한 값을 가지도록 증가되는 컬럼을 내부적으로 추가한 후, 클러스터링 키로 선택


## 세컨더리 인덱스 
MyISAM, MEMORY와 같이 클러스터링 되지 않은 테이블은 INSERT 시 처음 저장된 공간에서 절대로 이동하지 않느다. 데이터 레코드가 저장된 주소는 
내부적 레코드 아이디(ROWID) 역할을 한다. PK나 세컨더리 인덱스의 각 키는 그 ROWID를 이용해서 실제 레코드를 찾는다.

innoDB의 세컨더리 인덱스가 실제 저장 주소를 가지고 있다면? 클러스터링 키 값이 변경될 때마다 데이터 레코드 주소가 변경되고 그 때마다 해당 테이블의 모든 인덱스에
저장된 주솟 값을 변경해야 한다. 이런 오버헤드를 제거하기 위해서 모든 세컨더리 인덱스는 해당 레코드가 저장된 주소가 아니라 PK 값을 저장하도록 구현돼 있다. 

## 클러스터링 인덱스의 장/단점

|  \  |                                                                                                                                                                                                                                              |
|:---:|:---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 장점  | - PK(클러스터링키)로 검색할 때 처리 성능이 매우 빠름( 특히 범위 검색 )<br/> - 테이블의 모든 세컨더리 인덱스가 PK를 가지고 있기 때문에 인덱스만으로 처리할 수 있는 경우가 많은 (커버링 인덱스)                                                                                                                        |
| 단점  | - 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스 크기가 커짐<br/> - 세컨더리 인덱스를 통해 검색할 때 PK키로 다시 한 번 검색해야 하므로 처리 성능이 느림 <br/> - INSERT 시 PK에 의해 레코드 저장 위치가 결정되기 떄문에 처리 성능이 느림 <br/> - PK 변경시 레코드를 DELETE ->  INSERT해야 해서 처리 성능이 느림 |



## 클러스터링 테이블 주의 사항
### 클러스터링 인덱스 키의 크기
클러스터링 테이블의 경우 모든 세컨더리 인덱스가 PK 값을 포함한다. 그래서 PK가 커지면 세컨더리 인덱스도 자동으로 크기가 커진다. 

### PK는 AUTO-INCREMENT보다는 비즈니스 적으로 의미가 있도록 설정한다. 
innoDB PK는 클러스터링 키로 사용되며 레코드의 위치가 결정된다. 따라서 PK로 검색하면 속도적 측면에서 이점을 볼 수 있다. 그러므로 컬럼 크기가 크더라도
비즈니스적으로 레코드를 대표할 수 있다면 그 컬럼을 PK로 설정하는 것이 좋다 

### PK는 명시할 것
만약 PK를 정하기 어렵다면 꼭 AUTO-INCREMENT라도 사용하는 것이 좋다. PK를 정의하지 않으면 innoDB 내부적으로 일련번호 컬럼을 추가한다. 문제는 이 컬럼은
노출되지 않기에 사용할 수 없다. 또한 ROW 기반 복제나 innoDB Cluster에서는 모든 테이블이 PK를 가져야만 정상적인 복제 성능을 보장한다.


## UNIQUE
innoDB에서 유니크는 제약 조건이지만 인덱스 없이 설정할 수 없다.  여기서 인덱스라고 표현했다고 성능상 이점이 있을 것이라 생각하면 안된다. 오히려 INSERT 에서
중복 비교 과정이 생겨서 느려질 수도 있다. 

## FK
MySQL에서는 FK를 innoDB에서만 생성할 수 있다. FK가 설정되면 자동으로 연관 테이블까지 인덱스가 생성된다. FK 제거 없이 자동으로 생성된 인덱스를 삭제할 수 없다.
FK 관리에는 두 가지 특징이 있다.
1. 테이블 변경 (쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)이 생긴다.
2. FK가 연관되지 않은 컬럼 변경은 최대한 잠금 경함(잠금 대기)가 발생시키지 않는다.
